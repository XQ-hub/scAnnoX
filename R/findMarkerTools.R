#' println

#' Print prompt message.
#' @param infos Message that need to be printed.
#' @param verbose Bool value, print out messages or not, default: TRUE.
#' @param status (optional) Status of running messages or error. Default: INFO.
#' @return NULL.
#' @export println
#'
#' @examples
#' println('Begin analysis ->', verbose = TRUE, status = 'INFO', 'example')

println <- function(X, verbose = TRUE, status = c('INFO', 'WARN', 'ERROR')) {
    status <- match.arg(status)
    infos <- X %>% paste0('[', status, '] ', .)
    if (verbose || status == 'ERROR') {
        cat(paste0(infos, '\n'))
        if (status == 'ERROR') stop()
    }
}

downSamplSeurat <- function(obj, seed = 123, percent = 0.5){
  set.seed(seed)
  cells <- Idents(obj) %>% table
  sub.cells <- sapply(names(cells), function(xx) {
    sub.cells <- Idents(obj)[Idents(obj) == xx] %>% names
    cnt <- ifelse(is.null(percent), cnt, length(sub.cells) * percent)
    if (length(sub.cells) > cnt) 
      sub.cells <- sample(sub.cells, cnt, replace = FALSE)
    return(sub.cells) }) %>% unlist(use.names = F)
  subset(obj, cells = sub.cells)
}

#' multipleProcess

#' Open multiple workers for Seurat processing.
#' @param n.workers Number of cores. Default: 10.
#' @return NULL
#' @export multipleProcess
#'
#' @examples
#' multipleProcess(n.workers = 10)

multipleProcess <- function(n.workers = 10) {
    options(future.globals.maxSize = 500000 * 1024^2, future.seed = TRUE)
    future::plan("multicore", workers = n.workers)
}

#' println

#' Print prompt message.
#' @param infos Message that need to be printed.
#' @param verbose Bool value, print out messages or not, default: TRUE.
#' @param status (optional) Status of running messages or error. Default: INFO.
#' @return NULL.
#' @export println
#'
#' @examples
#' println('Begin analysis ->', verbose = TRUE, status = 'INFO', 'example')

println <- function(X, verbose = TRUE, status = c('INFO', 'WARN', 'ERROR')) {
    status <- match.arg(status)
    infos <- X %>% paste0('[', status, '] ', .)
    if (verbose || status == 'ERROR') {
        cat(paste0(infos, '\n'))
        if (status == 'ERROR') stop()
    }
}

#' collapseLisToFrame

#' Collapse the list to data.frame, which contains two coloumns, one is list names, and another is correponding values.
#' @param marker.lst A list with names.
#' @return A collapsed data.frame.
#' @export collapseLisToFrame
#' @examples
#' my.list <- list(a = c(1, 2, 3), b = c("foo", "bar"), c = 4:6)
#' collapseLisToFrame(my.list)

collapseLisToFrame <- function(marker.lst) {
    marker.lst <- data.frame(
        name = rep(names(marker.lst), lengths(marker.lst)),
        value = unlist(marker.lst)
    )
    return(marker.lst)
}

#' multipleProcess

#' Open multiple workers for Seurat processing.
#' @param n.workers Number of cores. Default: 10.
#' @return NULL
#' @export multipleProcess
#'
#' @examples
#' multipleProcess(n.workers = 10)

multipleProcess <- function(n.workers = 10) {
    options(future.globals.maxSize = 500000 * 1024^2, future.seed = TRUE)
    future::plan("multicore", workers = n.workers)
}

#' findMarkerToolsForSc

#' Find markers for subsets using publicly avaiable tools on the basis of single-cell data.
#' @param obj.seu Seurat object.
#' @param to.list Convert the results to a list or not. If TRUE, the names of the list represent the subset, and values are marker genes.
#' @param method A vector of publicly avaiable tools. Default: Seurat.
#' @param top.k Top k expressed genes of each subset remained. Default: NULL.
#' @param n.workers Number of cores for parallel when selected tool supported. Default: 4.
#' @param ... More arguments can be assessed from the corresponding tools.
#' @return A list of makers for the subsets or default format results generated by the selected tool.
#'
#' @examples
#' obj.seu <- system.file('data/test', 'test.obj.rds', package = 'Biotools') %>% readRDS(.)
#' results <- findMarkerToolsForSc(obj.seu, to.list = TRUE, method = 'Seurat', logfc.threshold = 0.25, min.pct = 0.25)

findMarkerToolsForSc <- function(
	obj.seu, 
	to.list = TRUE, 
	method = c('Seurat'), 
	top.k = NULL, 
	n.workers = 4,
	...
) {
	multipleProcess(n.workers)
	method <- match.arg(method)
	res.markers <- switch(
		method,
		Seurat = findMarkersBySeurat(obj.seu, to.list, top.k, ...)
	)
	return(res.markers)
}

#' findMarkersBySeurat

#' Find markers for each subset using the wilcox.test function wrapped in the FindAllMarkers function from the Seurat package.
#' @param obj.seu Seurat object.
#' @param to.list Convert the results to a list or not. If TRUE, the names of the list represent the subset, and values are marker genes.
#' @param top.k Top k expressed genes of each subset remained. Default: NULL.
#' @param ... More arguments can be assessed using the FindAllMarkers function in the Seurat package.
#' @return A list of makers for the subsets or default format results generated by Seurat package.
#' @export findMarkersBySeurat
#' 
#' @examples
#' obj.seu <- system.file('data/test', 'test.obj.rds', package = 'Biotools') %>% readRDS(.)
#' results <- findMarkersBySeurat(obj.seu, to.list = TRUE, logfc.threshold = 0.25, min.pct = 0.25)

findMarkersBySeurat <- function(obj.seu, to.list = TRUE, top.k = NULL, ...) {
	de.markers <- FindAllMarkers(obj.seu, ...)
	if (!is.null(top.k)) de.markers <- de.markers %>% group_by(cluster) %>% top_n(n = top.k, wt = avg_log2FC)
	if (to.list) de.markers <- split(de.markers$gene, de.markers$cluster)	
	return(de.markers)
}
